<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="google-site-verification" content="aG_tXROG9wF9yK4g29KmnltUUXyLK5SBAWKIXDkz6vU"><meta name="msvalidate.01" content="2CB4988EF2694D3ED16C6614D070E697"><title>【翻译】React.js 初学者应该知道的 9 件事 - Fedeoo&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Fedeoo&#039;s Blog"><meta name="msapplication-TileImage" content="/gallery/site/shark.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Fedeoo&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="原文地址：9 things every reactjs beginner should know 2016年1月份的文章，现在才翻译，又落后了半年  现在为止我使用 React.js  已经6 个月了。6 个月 放长远看一点也不长。但是，在 JavaScript 框架层出不穷的今天，6 个月可以称为老前辈了。最近指点了几个新人入门 React ，所以想总结一下写篇文章启发更多的人。下面总结的这些"><meta property="og:type" content="blog"><meta property="og:title" content="【翻译】React.js 初学者应该知道的 9 件事"><meta property="og:url" content="http://blog.feibyte.com/2016/07/18/novice/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91React-js-%E5%88%9D%E5%AD%A6%E8%80%85%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84-9-%E4%BB%B6%E4%BA%8B/"><meta property="og:site_name" content="Fedeoo&#039;s Blog"><meta property="og:description" content="原文地址：9 things every reactjs beginner should know 2016年1月份的文章，现在才翻译，又落后了半年  现在为止我使用 React.js  已经6 个月了。6 个月 放长远看一点也不长。但是，在 JavaScript 框架层出不穷的今天，6 个月可以称为老前辈了。最近指点了几个新人入门 React ，所以想总结一下写篇文章启发更多的人。下面总结的这些"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.feibyte.com/img/og_image.png"><meta property="article:published_time" content="2016-07-18T06:24:56.000Z"><meta property="article:modified_time" content="2024-05-16T11:33:02.128Z"><meta property="article:author" content="Fedeoo"><meta property="article:tag" content="React"><meta property="article:tag" content="翻译"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://blog.feibyte.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.feibyte.com/2016/07/18/novice/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91React-js-%E5%88%9D%E5%AD%A6%E8%80%85%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84-9-%E4%BB%B6%E4%BA%8B/"},"headline":"【翻译】React.js 初学者应该知道的 9 件事","image":["http://blog.feibyte.com/img/og_image.png"],"datePublished":"2016-07-18T06:24:56.000Z","dateModified":"2024-05-16T11:33:02.128Z","author":{"@type":"Person","name":"Fedeoo"},"publisher":{"@type":"Organization","name":"Fedeoo's Blog","logo":{"@type":"ImageObject","url":"http://blog.feibyte.com/gallery/site/logo.png"}},"description":"原文地址：9 things every reactjs beginner should know 2016年1月份的文章，现在才翻译，又落后了半年  现在为止我使用 React.js  已经6 个月了。6 个月 放长远看一点也不长。但是，在 JavaScript 框架层出不穷的今天，6 个月可以称为老前辈了。最近指点了几个新人入门 React ，所以想总结一下写篇文章启发更多的人。下面总结的这些"}</script><link rel="canonical" href="http://blog.feibyte.com/2016/07/18/novice/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91React-js-%E5%88%9D%E5%AD%A6%E8%80%85%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84-9-%E4%BB%B6%E4%BA%8B/"><link rel="icon" href="/gallery/site/shark.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-773NDPTQE0" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-773NDPTQE0');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/gallery/site/logo.png" alt="Fedeoo&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="English" href="https://blog.feibyte.com/en">English</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/feibyte/feibyte.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2016-07-18T06:24:56.000Z" title="18/07/2016, 4:24:56 pm">2016-07-18</time>发表</span><span class="level-item"><time dateTime="2024-05-16T11:33:02.128Z" title="16/05/2024, 9:33:02 pm">2024-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">实践总结</a></span><span class="level-item">36 分钟读完 (大约5337个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">【翻译】React.js 初学者应该知道的 9 件事</h1><div class="content"><blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://camjackson.net/post/9-things-every-reactjs-beginner-should-know">9 things every reactjs beginner should know</a><br> 2016年1月份的文章，现在才翻译，又落后了半年</p>
</blockquote>
<p>现在为止我使用 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/index.html">React.js</a>  已经6 个月了。6 个月 放长远看一点也不长。但是，在 JavaScript 框架层出不穷的今天，6 个月可以称为老前辈了。最近指点了几个新人入门 React ，所以想总结一下写篇文章启发更多的人。下面总结的这些点，一些点是我希望在自己入门的时候就已经知道的，另外一些则是让我真正的理解 React。</p>
<span id="more"></span>

<p>本文假定你已经有了一下基本的概念。如果你不熟悉 component、props 或者 state  这些名词，你最好先去阅读下官方<a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/getting-started.html">起步</a>和<a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/tutorial.html">手册</a>。下面的代码示例我将使用 JSX 作演示，因为使用 JSX 语法写组件更为简洁，也更具表达力。</p>
<h1 id="1-React-js-只是一个视图库"><a href="#1-React-js-只是一个视图库" class="headerlink" title="1. React.js 只是一个视图库"></a>1. React.js 只是一个视图库</h1><p>我们从最基本的开始。React 不是一个 MVC 框架，好吧，它根本就不是一个框架。它只是一个渲染视图的库。如果你对 MVC 熟悉的话，你就会意识到 React.js 只对应了<code>V</code> 这部分，如果它插手了 <code>M</code>  或 <code>C</code> 的逻辑，你就需要考虑用其它方法来解了。否则，到最后，你的代码很可能会变成一坨翔。这部分后面会细说。</p>
<h1 id="2-组件尽可能的小"><a href="#2-组件尽可能的小" class="headerlink" title="2. 组件尽可能的小"></a>2. 组件尽可能的小</h1><p>这一点有些显而易见，但是有必要强调一下。每个良好的程序员都知道，较小的类、模块更容易理解、测试和维护，对于组件来说也是一样。我起初犯的错误是低估了 React 组件合适的大小。当然，合适的大小取决于很多不同的因素（包括个人与团队偏好），但是，一般来说，我建议，让组件明显小于你本认为的必需大小。举个栗子，我的<a target="_blank" rel="noopener" href="https://camjackson.net/">个人网站</a>主页上的这个组件，用于展示我的最新博文：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">LatestPostsComponent</span> = props =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Latest posts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; props.posts.map(post =&gt; <span class="tag">&lt;<span class="name">PostPreview</span> <span class="attr">key</span>=<span class="string">&#123;post.slug&#125;</span> <span class="attr">post</span>=<span class="string">&#123;post&#125;/</span>&gt;</span>) &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个组件本身是一个 <code>&lt;section&gt;</code>，里面只有两个 <code>&lt;div&gt;</code>。第一个<code>&lt;div&gt;</code>有一个标题，第二个<code>&lt;div&gt;</code>只是映射一些数据，使用数据中的每个元素渲染 <code>&lt;PostPreview&gt;</code>。还有一部分抽取<code>&lt;PostPreview&gt;</code>作为独立组件，这点很重要。我认为这是一个组件最合适的大小。</p>
<h1 id="3-写函数式组件"><a href="#3-写函数式组件" class="headerlink" title="3. 写函数式组件"></a>3. 写函数式组件</h1><p>首先，我们有两种定义 React 组件的方式，第一种是用 <code>React.createClass()</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;/</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另一种是 ES6 class 写法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;/</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 0.14 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components">引入</a>了一个新语法来定义组件，使用属性作为参数的函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = props =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;props.className&#125;/</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这是我最喜欢的定义 React 组件的方式。除了语法上简洁，这种方法还能帮助你界定什么时候需要拆分组件了。我们来回顾下之前的例子，假设下面是没拆分之前的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LatestPostsComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> postPreviews = <span class="title function_">renderPostPreviews</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Latest posts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123; postPreviews &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">renderPostPreviews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">posts</span>.<span class="title function_">map</span>(<span class="function"><span class="params">post</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">renderPostPreview</span>(post));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">renderPostPreview</span>(<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`/<span class="attr">post</span>/$&#123;<span class="attr">post.slug</span>&#125;`&#125;&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">time</span> <span class="attr">pubdate</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>&#123;post.posted&#125;<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;post.blurb&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`/<span class="attr">post</span>/$&#123;<span class="attr">post.slug</span>&#125;`&#125;&gt;</span>Read more...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个 class 还凑合。我们已经从 render 方法中抽取了几个方法，方法足够小，命名合理。我们来试着用函数式的语法重写一下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">LatestPostsComponent</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> postPreviews = <span class="title function_">renderPostPreviews</span>(props.<span class="property">posts</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Latest posts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; postPreviews &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderPostPreviews</span> = posts =&gt; (</span><br><span class="line">  posts.<span class="title function_">map</span>(<span class="function"><span class="params">post</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">renderPostPreview</span>(post))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderPostPreview</span> = post =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`/<span class="attr">post</span>/$&#123;<span class="attr">post.slug</span>&#125;`&#125;&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">time</span> <span class="attr">pubdate</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>&#123;post.posted&#125;<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;post.blurb&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`/<span class="attr">post</span>/$&#123;<span class="attr">post.slug</span>&#125;`&#125;&gt;</span>Read more...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>代码基本一样，无非是将类里的方法暴露为函数。但是，对我来说，区别可大了。在基于类的例子中，我看到的是<code>class LatestPostsComponent &#123;</code>，自然而然会往下扫描闭合括号，然后在心中默想“在这儿这个类结束了，这个组件也到这”。对比函数式组件，我看到 <code>const LatestPostsComponent = props =&gt; &#123;</code>，看到函数结束，就已经知道“这个函数结束，组件也在这结束”。“但是，等等，这个组件外面的代码是些什么鬼？还在同一个模块，哦，这是另一个函数，接收数据然后渲染视图，我把它抽取到出来就行了”</p>
<p>我就不再啰嗦函数式组件有助于我们遵循上面第二点。</p>
<p>以后，React 也会做一些优化，会使函数式组件比基于类的组件更为高效。（__更新__：函数式组组件的性能影响比我想象的要复杂。但是，如果性能不是大的问题，我依然推荐尽可能的写函数式组件，你应该好阅读下<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/5677">这个</a>和<a target="_blank" rel="noopener" href="https://github.com/rackt/redux/issues/1176">这个</a>，选择一个合适自己的）</p>
<p>还有个重要的店，函数式组件有几个 ’限制‘ ，我个人认为是大优点。第一个是它不会有 <code>ref</code> 赋给它，<code>ref</code> 在查找子组件并与之通信上非常方便，我的感受是 这是使用 React 的 __错误方式__。<code>refs</code> 鼓励一种非常直接，近于 jqeury 的方式写组件，远离了 函数式，单向数据流哲学理念，这些理念恰恰是我们选择 React 的初衷！</p>
<p>另一个大的区别是函数式组件不会有状态依附，我下一个点就是讲…</p>
<h1 id="4-写无状态组件"><a href="#4-写无状态组件" class="headerlink" title="4.  写无状态组件"></a>4.  写无状态组件</h1><p>不得不说，到目前为止，我觉得写 React 应用，最让我头疼的事都是由包含很多状态的组件引起的。</p>
<h2 id="状态让组件很难测试"><a href="#状态让组件很难测试" class="headerlink" title="状态让组件很难测试"></a>状态让组件很难测试</h2><p>单纯的输入输出函数是最容易测试的，这点可以作为抛弃状态定义组件的理由吗？当我们测试很多状态的组件时，为了测试预期行为，我们必须先将组件设置为“正确的状态”。我们还必须考虑到所有的状态（因为组件可能在任意时刻改变这些状态）和属性（不受组件控制）组合，然后再去考虑那个组合需要测试，怎么测试。如果组件只是一个输入属性的处理函数，测试简直是不能更简单了。（关于测试，后面会讲）。</p>
<h2 id="状态让组件很难推理（定位预期）"><a href="#状态让组件很难推理（定位预期）" class="headerlink" title="状态让组件很难推理（定位预期）"></a>状态让组件很难推理（定位预期）</h2><p>当你读一段代码中包含很多状态的组件，特别费劲，你需要在脑海中记录组件的状态。这些问题：”状态有没有初始化？”，“如果我在这儿改变状态将会发生什么？”，“有几个地方改变了这个状态”，“这个状态是否存在条件竞争？”，这几个问题非常普遍。跟踪组件变化太蛋疼了。</p>
<h2 id="状态让组件很容易引入业务逻辑"><a href="#状态让组件很容易引入业务逻辑" class="headerlink" title="状态让组件很容易引入业务逻辑"></a>状态让组件很容易引入业务逻辑</h2><p>我们不应该搜索组件然后才能确定行为。记住，React 只是一个视图库，所以，把渲染逻辑丢在组件里面没问题，但是业务逻辑也丢里面就有问题了。但是呢，如果你的应用状态都在组件里面，那在组件内部访问这些状态就会很方便，这样就会诱使你把业务逻辑也丢在里面。回顾下刚说的那点，这么做单元测试怎么办 - 没有业务逻辑你没法测试渲染逻辑，反之亦然。</p>
<h2 id="状态让组件很难与应用其它部分共享信息"><a href="#状态让组件很难与应用其它部分共享信息" class="headerlink" title="状态让组件很难与应用其它部分共享信息"></a>状态让组件很难与应用其它部分共享信息</h2><p>父层组件的状态很容易传给下层组件，反过来就费事了。</p>
<p>当然，有时一个组件独立维护部分状态也是有必要的。在这种情况下，尽管放心使用 <code>this.setState</code> 。它也是 React 组件 API 合理的一部分，我并不想是让你觉得应该禁用它。比如，在用户输入时，不需要把每个按键都暴露给整个应用，应该保存自己的状态，在失去焦点之后，输入值会被派发到其它地方存储起来。这种场景是最近一个同事提到的，我觉得这个例子非常恰当。</p>
<p>为组件添加状态还是需要慎重。一旦你开始了，就很容易再加一个状态，不知不觉就不受你控制了。</p>
<h1 id="5-使用-Redux-js"><a href="#5-使用-Redux-js" class="headerlink" title="5. 使用 Redux.js"></a>5. 使用 Redux.js</h1><p>上面第一点就已经说过，React 只是一个视图库。那么问题来了，“状态和逻辑放哪儿？”  我很高兴你会这么问！<br>你可能已经知道 Flux ，一种设计 web 应用的模式，在 React 开发中较为普遍。已经有几个基于 Flux 思想的实现，但是毫无疑问我推荐使用 Redux.js 。</p>
<p>我在考虑写一篇单独的博客，关于 Redux 的特性和优点。目前我推荐你读下官方文档，在这儿我只简单描述下它的工作原理：</p>
<ol>
<li>组件上的 UI 事件触发时，它们执行属性上传入的回调函数。</li>
<li>这些基于事件创建的回调函数派发 actions</li>
<li>Reducers 处理 actions 并计算新的状态</li>
<li>整个应用的新状态流入单一的 store</li>
<li>组件接收新状态作为属性，在需要时重绘</li>
</ol>
<p>上面的这些概念并非 Redux 独创，但是 Redux 的实现比较清晰简单。从 Alt.js 切换到 Redux ，减少了很多代码量，这儿简单列出比较突出的优点：</p>
<ol>
<li>reducers 是纯函数，简单的 <code>oldState + action = newState</code>。每个 reducer 只处理一部分状态，这些状态可以组合起来。这么做，所有的业务逻辑和状态转换很容易测试。</li>
<li>API 很少，很简单，文档清晰。非常容易学习这些概念，因此很容易理解项目中 actions 和 数据 的流动过程。</li>
<li>按照推荐的方式使用，只有很少的组件依赖 Redux ; 其它的组件只接收状态和回调作为属性。这么做可以保持组件非常简单，减少框架同步。</li>
</ol>
<p>这儿有几个库配合 Redux 非常爽，我也推荐你使用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://facebook.github.io/immutable-js/">Immutable.js</a> JavaScript 不可变数据结构！用它存储你的状态，可以确保状态不会在不该改变的时候改变，并且能够保障 reducer 足够纯洁。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/gaearon/redux-thunk">redux-thunk</a> 当你的 actions 不只是更新应用状态，还有其他副作用时，就派上用场。比如，调用 REST API，设置路由或者派发其他 actions</li>
<li><a target="_blank" rel="noopener" href="https://github.com/reactjs/reselect">reselect</a>  用于可组合的，懒计算的情形。例如，对于部分组件，你可能想要:</li>
<li>只注入整个状态树的相关部分，而非整个</li>
<li>注入额外的衍生数据，比如总数或验证状态，而不需放在 store 中</li>
</ul>
<p> 没有必要在最开始的时候就把这些全部引进来。当你开始有状态时，就可以引入 Redux 和 Immutable.js，有派生状态时引入 reselect，有路由或异步 actions 时引入 redux-thunk。尽早在必要时引入可以省去之后重构的时间。</p>
<p>Redux 是不是真正的 Flux，每个人都有自己的见解。个人觉得它符合 Flux 框架的核心思想，不过这个争论只是个语义问题。</p>
<h1 id="6-一直使用-propTypes"><a href="#6-一直使用-propTypes" class="headerlink" title="6. 一直使用 propTypes"></a>6. 一直使用 propTypes</h1><p><a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/reusable-components.html#prop-validation">propTypes</a> 很容易为组件添加类型安全保障。他们看起来像这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ListOfNumbers</span> = props =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">className</span>=<span class="string">&#123;props.className&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;</span></span><br><span class="line"><span class="language-xml">      props.numbers.map(number =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">      )</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ListOfNumbers</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">className</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  <span class="attr">numbers</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">arrayOf</span>(<span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在开发阶段（生产不会），如果任何组件没有给到必需的属性，或者所给的属性与声明的不匹配，React 会打印这些错误信息通知你。这有几点好处：</p>
<ul>
<li>防止低级错误，捕获 bugs</li>
<li>如果你使用 <code>isRequired</code>，你就不需要检查 <code>undefined</code> 或 <code>null</code></li>
<li>就像文档所说，列出组件的所有属性，省去阅读代码的人搜索整个组件。</li>
</ul>
<p>上面的这些点，你可能似曾相识，静态类型支持者的论点。个人来讲，我通常喜欢动态类型带来的开发速度和舒适，但是我发现 propTypes 可以毫不费力的为我的组件添加一些安全感。坦白讲，没有理由不一直用它们。<br>最后一点是，任何 propType 错误时，让你的测试用例失败。下面这个例子有点简单粗暴的，不过可行：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeAll</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="property">error</span> = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(error);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="7-使用浅渲染"><a href="#7-使用浅渲染" class="headerlink" title="7. 使用浅渲染"></a>7. 使用浅渲染</h1><p>测试 React 组件依然是有点棘手的话题。不是因为太难，而是因为还在发展，还没有出现一个最佳方案。目前来看，我的 go-to 方法是使用 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/test-utils.html#shallow-rendering">浅渲染</a>和属性断言。</p>
<p>浅渲染很好用，它允许你完整的渲染一个单一组件，而不涉及子元素的渲染。也就是说，结果对象只会告诉你子元素的类型和属性。这样子单一组件单一时间点可以提供很好的隔离。这儿有三种类型的组件单元测试，我自己也经常这么做：</p>
<h2 id="渲染逻辑"><a href="#渲染逻辑" class="headerlink" title="渲染逻辑"></a>渲染逻辑</h2><p>假定一个组件，因条件不同，可能会显示一张图片，或者一个加载图标：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Image</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">loading</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">LoadingIcon</span>/&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;props.src&#125;/</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以这么测试：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Image&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders a loading icon when the image is loading&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="title function_">shallowRender</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">loading</span>=<span class="string">&#123;true&#125;/</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(image.<span class="property">type</span>).<span class="title function_">toEqual</span>(<span class="title class_">LoadingIcon</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders the image once it has loaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="title function_">shallowRender</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">loading</span>=<span class="string">&#123;false&#125;</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/image.jpg&quot;</span>/&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(image.<span class="property">type</span>).<span class="title function_">toEqual</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>非常简单！当然，浅渲染的API 略微比我展示的复杂。上面使用的浅渲染函数是我们自己的 辅助方法，这个辅助方法包装了真正的 API，使用起来更简单一些。<br>回头看下我们的 <code>ListOfNumbers</code> 组件，下面是我们如何测试映射结果确实正确：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;ListOfNumbers&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;renders an item for each provided number&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listOfNumbers = <span class="title function_">shallowRender</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ListOfNumbers</span> <span class="attr">className</span>=<span class="string">&quot;red&quot;</span> <span class="attr">numbers</span>=<span class="string">&#123;[3,</span> <span class="attr">4</span>, <span class="attr">5</span>, <span class="attr">6</span>]&#125;/&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">expect</span>(listOfNumbers.<span class="property">props</span>.<span class="property">children</span>.<span class="property">length</span>).<span class="title function_">toEqual</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h2><p>在最后的例子中，我们深入测试组件的子元素，确保它们被正确渲染。我们不止断言组件是否存在，同时检查所给的属性是否正确。当组件确实在传递属性之前根据属性做些转换时，这点特别有用。例如，下面这个组件接受一个字符串数组作为 CSS 类名，往下传递一个单引号空白分割的字符串：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">TextWithArrayOfClassNames</span> = props =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;props.classNames.join(</span>&#x27; &#x27;)&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">     &#123;props.text&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;TextWithArrayOfClassNames&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;turns the array into a space-separated string&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> classNames = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;float-right&#x27;</span>];</span><br><span class="line">    <span class="keyword">const</span> textWithArrayOfClassNames = <span class="title function_">shallowRender</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">TextWithArrayOfClassNames</span> <span class="attr">text</span>=<span class="string">&#123;text&#125;</span> <span class="attr">classNames</span>=<span class="string">&#123;classNames&#125;/</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> childClassNames = textWithArrayOfClassNames.<span class="property">props</span>.<span class="property">children</span>.<span class="property">props</span>.<span class="property">className</span>;</span><br><span class="line">    <span class="title function_">expect</span>(childClassNames).<span class="title function_">toEqual</span>(<span class="string">&#x27;red bold float-right&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对这样方法最多的批判是激增的 <code>props.children.props.children</code> 。当然这不是最完美的代码，个人觉得如果一个测试中的 <code>props.children</code> 多的让人受不了，这说明这个组件太大了，太复杂了，嵌套太深。它可能需要拆分。<br>另外一点，我经常听说的是，你的测试太依赖你的组件内部实现，以至于稍微改变你的 DOM 结构都能导致你所有的测试崩溃。这的确是一个很公正的评论，脆弱的测试套件是每个人想要的最好件事。管理这些最好的方式是保持你的组件足够小，足够简单，应该控制因组件变更引起的测试崩溃数目。</p>
<h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><p>当然，组件不止展示，还有交互：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">RedInput</span> = props =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">className</span>=<span class="string">&quot;red&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;props.onChange&#125;</span> /&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这是我最喜欢的测试方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;RedInput&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;passes the event to the given callback when the value changes&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> callback = jasmine.<span class="title function_">createSpy</span>();</span><br><span class="line">    <span class="keyword">const</span> redInput = <span class="title function_">shallowRender</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">RedInput</span> <span class="attr">onChange</span>=<span class="string">&#123;callback&#125;/</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    redInput.<span class="property">props</span>.<span class="title function_">onChange</span>(<span class="string">&#x27;an event!&#x27;</span>);</span><br><span class="line">    <span class="title function_">expect</span>(callback).<span class="title function_">toHaveBeenCalledWith</span>(<span class="string">&#x27;an event!&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这只是一个例子，希望你能受到启发。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>上面我内容只覆盖到组件的独立的单元测试，但是你可能想确保你的应用各个部分协同工作，想在测试上走的更远。我对这部分了解的不够深入，但是列出一些基本点：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/test-utils.html#renderintodocument">渲染你的整个组件树</a>（而非浅渲染）</li>
<li>访问 DOM （使用 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/test-utils.html">React TestUtils</a> 或 <a target="_blank" rel="noopener" href="https://jquery.com/">jQuery</a> 等等）找到你最关系的元素，然后</li>
<li>断言元素的 HTML 属性和内容</li>
<li><a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/test-utils.html#simulate">模拟 DOM 事件</a>，然后断言产生的效果（DOM 或 路由变化，AJAX 调用等等）</li>
</ol>
<h2 id="关于测试驱动开发"><a href="#关于测试驱动开发" class="headerlink" title="关于测试驱动开发"></a>关于测试驱动开发</h2><p>一般情况下，写React 组件时我并不使用测试驱动开发。</p>
<p>在开发组件的时候，我发现我经常会去改动它的结构，我需要使用最简单的 HTML 和 CSS，在需要支持的浏览器上保持一致。因为我的组件单元测试方法大多会断言组件的结构，而测试驱动开发会使我在修改DOM时，忙于修复测试用例，这看起来有点浪费时间。<br>另外一个因素是组件足够简单以至于测试优先的有点基本消失。所有复杂的逻辑和转换都会丢在 action creators 和 reducers，这些地方我能真正享受到测试驱动开发带来的便利。<br>关于测试还有最后一点需要说明。整节内容我都在讨论测试组件，是因为测试基于 Redux 应用的其它部分没有特别之处。作为一个框架，Redux 背后还有些 ‘魔力’ ，可以减少对 mock 和其它测试模板的依赖。每个函数只是一个普通的函数（大多数是纯函数），测试起来真是如沐春风。</p>
<h1 id="8-使用-JSX-ES6-Babel-Webpack-和-NPM"><a href="#8-使用-JSX-ES6-Babel-Webpack-和-NPM" class="headerlink" title="8. 使用 JSX, ES6, Babel, Webpack 和 NPM"></a>8. 使用 JSX, ES6, Babel, Webpack 和 NPM</h1><p>只有 JSX 是 React 特有的。对我来说，JSX 是 <code>React.createElement</code> 的无脑操作。唯一的不足是增加了构建的复杂度，这个问题可以用 <a target="_blank" rel="noopener" href="https://babeljs.io/">Babel</a> 轻松搞定。<br>既然用了 Babel，那没理由不用 <a target="_blank" rel="noopener" href="http://es6-features.org/">ES6 特性</a>，像 常量，箭头函数，默认参数，数组和对象解构，延展和 rest 操作，字符串模板，迭代器和生成器，模块系统，等等。只要你花一点时间设置这个工具，你就能感受到 JavaScript 语言越来越成熟。<br>让我们做的更全面一些，使用 <a target="_blank" rel="noopener" href="https://webpack.github.io/">Webpack</a> 打包代码，使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">NPM</a> 管理包。现在我们完全赶上了 JavaScript 的潮流 :)。</p>
<h1 id="9-使用-React-和-Redux-开发工具"><a href="#9-使用-React-和-Redux-开发工具" class="headerlink" title="9. 使用 React 和 Redux 开发工具"></a>9. 使用 React 和 Redux 开发工具</h1><p>谈到工具，React 和 Redux 的开发工具太赞了。<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">React dev tools</a> 让你审查 React 元素的渲染树，在查看浏览器中结果时相当有用。Redux dev tools 更是<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=xsSnOQynTHs">让人眼前一亮</a>，让你看到每个 已经发生的 action ，它们引起的状态变化，甚至给你回退的能力！你可以作为<a target="_blank" rel="noopener" href="https://github.com/gaearon/redux-devtools">开发依赖</a>，或者<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en">浏览器扩展</a>的形式使用。<br>你也可以用webpack设置热切换，保存代码时你的页面也会跟着更新-浏览器无需刷新。在调整组件和 reducers 时可以立即看到效果，大大提高开发效率。</p>
<p>就这些！<br>我希望在 React 入门上能带给你一个好的开端，帮你避免一些常见的错误。如果你喜欢这篇文档，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/camjackson89">Twitter</a> 或者订阅我的 <a target="_blank" rel="noopener" href="https://camjackson.net/atom.xml">RSS</a> 。</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/React/">React</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2017/01/01/novice/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88AngularJS-%E5%92%8C-React%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">前端框架的最佳实践（AngularJS 和 React）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2016/05/15/novice/%E5%B0%B1%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/"><span class="level-item">就一个静态页面</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://blog.feibyte.com/2016/07/18/novice/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91React-js-%E5%88%9D%E5%AD%A6%E8%80%85%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84-9-%E4%BB%B6%E4%BA%8B/';
            this.page.identifier = '2016/07/18/novice/【翻译】React-js-初学者应该知道的-9-件事/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'blog-feibyte-com' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/gallery/site/shark.png" alt="Fedeoo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Fedeoo</p><p class="is-size-6 is-block">Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Sydney</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">51</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">学习笔记</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"><span class="level-start"><span class="level-item">实践总结</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">技术杂谈</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">设计实现</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/07/07/Designing-data-intensive-applications-note-part-two/"><img src="/gallery/thumbnails/2024/designing-data-intensive-applications-book.png" alt="《Designing Data Intensive Applications》读书笔记其二"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-07-07T13:17:22.000Z">2024-07-07</time></p><p class="title"><a href="/2024/07/07/Designing-data-intensive-applications-note-part-two/">《Designing Data Intensive Applications》读书笔记其二</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/06/07/Designing-data-intensive-applications-note/"><img src="/gallery/thumbnails/2024/designing-data-intensive-applications-book.png" alt="《Designing Data Intensive Applications》读书笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-06-07T13:17:22.000Z">2024-06-07</time></p><p class="title"><a href="/2024/06/07/Designing-data-intensive-applications-note/">《Designing Data Intensive Applications》读书笔记</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/06/07/The-DynamoDB-Book-note/"><img src="/gallery/thumbnails/2024/dynamodb-book.png" alt="《The DynamoDB Book》读书笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-06-07T13:17:22.000Z">2024-06-07</time></p><p class="title"><a href="/2024/06/07/The-DynamoDB-Book-note/">《The DynamoDB Book》读书笔记</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/06/02/DynamoDB%20single%20table%20design/"><img src="/gallery/thumbnails/2024/dynamodb.png" alt="DynamoDB 单表设计的优势与考量"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-06-02T11:22:56.000Z">2024-06-02</time></p><p class="title"><a href="/2024/06/02/DynamoDB%20single%20table%20design/">DynamoDB 单表设计的优势与考量</a></p><p class="categories"><a href="/categories/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">实践总结</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/05/21/AWS-connect-last-agent-call-routing/"><img src="/gallery/thumbnails/2024/call-center.png" alt="AWS Connect 转接最近通话的客服"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-05-21T11:22:56.000Z">2024-05-21</time></p><p class="title"><a href="/2024/05/21/AWS-connect-last-agent-call-routing/">AWS Connect 转接最近通话的客服</a></p><p class="categories"><a href="/categories/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">实践总结</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AWS/"><span class="tag">AWS</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Serviceless/"><span class="tag">Serviceless</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DataBase/"><span class="tag">DataBase</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DynamoDB/"><span class="tag">DynamoDB</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/gallery/site/logo.png" alt="Fedeoo&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Fedeoo</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>